# 智能上下文管理

## 功能介绍

智能上下文管理是 feapder 的一项创新功能，通过**静态代码分析 + 运行时参数捕获**，自动管理爬虫回调链中的参数传递，帮助你：

- ✅ **告别手动参数传递** - 无需在每个 Request 中手动指定要传递的参数
- ✅ **自动捕获三种参数来源** - 局部变量、request 属性、显式传入，全自动处理
- ✅ **最小化内存占用** - 只传递目标回调实际需要的参数
- ✅ **保持代码清晰** - 代码更简洁，意图更明确
- ✅ **零学习成本** - 只需一个参数 `auto_inherit_context=True`

---

## 快速开始

### 传统方式 vs 智能方式

**传统方式**（需要手动传递参数）:
```python
class MySpider(feapder.Spider):
    def start_requests(self):
        yield feapder.Request(
            "https://example.com/products",
            callback=self.parse_list,
            category_id=123,
            shop_name='测试店铺'
        )

    def parse_list(self, request, response):
        category_id = request.category_id
        shop_name = request.shop_name

        for item in items:
            item_id = response.xpath('//div/@data-id').get()

            yield feapder.Request(
                url=item_url,
                callback=self.parse_detail,
                category_id=category_id,  # ❌ 需要手动传递
                shop_name=shop_name,      # ❌ 需要手动传递
                item_id=item_id           # ❌ 需要手动传递
            )

    def parse_detail(self, request, response):
        category_id = request.category_id
        shop_name = request.shop_name
        item_id = request.item_id
```

**智能方式**（自动传递）:
```python
class MySpider(feapder.Spider):
    __custom_setting__ = dict(
        SMART_CONTEXT_ENABLE=True,  # ✅ 启用智能上下文
    )

    def start_requests(self):
        yield feapder.Request(
            "https://example.com/products",
            callback=self.parse_list,
            auto_inherit_context=True,  # ✅ 启用智能继承
            category_id=123,
            shop_name='测试店铺'
        )

    def parse_list(self, request, response):
        category_id = request.category_id
        shop_name = request.shop_name

        for item in items:
            item_id = response.xpath('//div/@data-id').get()

            # ✅ 完全不需要手动传参数！
            yield feapder.Request(
                url=item_url,
                callback=self.parse_detail,
                auto_inherit_context=True  # ✅ 只需这一个参数
                # category_id, shop_name, item_id 会自动传递
            )

    def parse_detail(self, request, response):
        category_id = request.category_id  # ✅ 自动继承
        shop_name = request.shop_name      # ✅ 自动继承
        item_id = request.item_id          # ✅ 自动继承
```

---

## 工作原理

### 两个阶段

#### 1️⃣ 静态分析阶段（Spider 启动时）

```
1. 使用 Python AST 分析所有回调函数的代码
2. 检测每个函数访问了 request.xxx 的哪些属性
3. 生成参数需求映射表
```

**示例**:
```python
def parse_detail(self, request, response):
    category_id = request.category_id  # 检测到 category_id
    item_id = request.item_id          # 检测到 item_id

# 分析结果: {'parse_detail': {'category_id', 'item_id'}}
```

#### 2️⃣ 运行时捕获阶段（创建 Request 时）

```
1. 查询目标回调函数需要哪些参数
2. 从三种来源自动捕获参数：
   【来源1】调用者函数中的局部变量
   【来源2】从父 request 获取的变量
   【来源3】Request 中显式传入的参数
3. 自动过滤掉不需要的参数
```

### 三种参数来源

```python
def parse_list(self, request, response):
    # 【来源1】直接定义的局部变量
    shop_name = "店铺A"
    category_level = 1

    # 【来源2】从 request 获取的变量
    category_id = request.category_id
    site_id = request.site_id

    # 【来源3】在 Request 中显式传入
    yield feapder.Request(
        url=url,
        callback=self.parse_detail,
        auto_inherit_context=True,
        item_id=123  # 显式传入
        # shop_name, category_level, category_id, site_id 会自动捕获
    )
```

**捕获优先级**：
- **最高优先级**：【来源3】显式传入的参数
- **次优先级**：【来源1/2】调用者函数的局部变量
- **保底继承**：如果前两者都没有，从父 request 继承

---

## 使用方法

### 1. 启用智能上下文

在 Spider 的 `__custom_setting__` 中配置:

```python
class MySpider(feapder.Spider):
    __custom_setting__ = dict(
        SMART_CONTEXT_ENABLE=True,  # 启用智能上下文分析
    )
```

**支持的 Spider 类型**:
- ✅ AirSpider
- ✅ Spider
- ✅ TaskSpider
- ✅ BatchSpider

### 2. 使用自动继承

在创建 Request 时添加 `auto_inherit_context=True`:

```python
yield feapder.Request(
    url=url,
    callback=self.parse,
    auto_inherit_context=True,  # 启用自动继承
    new_param=value  # 新增的参数（可选）
)
```

---

## 配置说明

### 全局配置

在 `setting.py` 或 `__custom_setting__` 中配置:

```python
# 是否启用智能上下文，默认 False
SMART_CONTEXT_ENABLE = True

# 智能上下文传递模式，默认 "transitive"
# - "direct": 只传递给下一层回调需要的参数
# - "transitive": 传递给当前回调及所有后续回调需要的参数（推荐）
SMART_CONTEXT_MODE = "transitive"
```

### 传递模式详解

#### transitive 模式（推荐，默认）

传递给**当前回调及所有后续回调**需要的参数，即使中间层不使用也会传递。

**适用场景**: 多层回调链，参数需要跨越多层传递

```python
# 10层回调示例
def parse_level_1(self, request, response):
    level_1_data = "数据A"  # 第1层定义
    yield Request(url, callback=self.parse_level_2, auto_inherit_context=True)

def parse_level_2(self, request, response):
    data = request.level_1_data  # 第2层使用
    yield Request(url, callback=self.parse_level_3, auto_inherit_context=True)

# parse_level_3 到 parse_level_9 都不使用 level_1_data

def parse_level_10(self, request, response):
    data = request.level_1_data  # ✅ 第10层仍然能获取到（transitive模式）
```

#### direct 模式

只传递给**下一层回调**需要的参数，如果下一层不使用则丢弃。

**适用场景**: 简单的单层回调，想节省内存

```python
# 同样的10层回调示例，使用 direct 模式
SMART_CONTEXT_MODE = "direct"

# parse_level_10 将无法获取到 level_1_data ❌
# 因为 parse_level_3 不需要，参数在第3层就被丢弃了
```

**推荐**: 使用默认的 `transitive` 模式，除非你确定不需要跨多层传递。

### Request 参数

```python
yield feapder.Request(
    url="https://example.com",
    callback=self.parse,
    auto_inherit_context=True,  # 是否启用智能继承，默认 False
    **kwargs  # 自定义参数
)
```

---

## 完整示例

### 示例1：电商爬虫

```python
class EcommerceSpider(feapder.Spider):
    __custom_setting__ = dict(
        SMART_CONTEXT_ENABLE=True,
    )

    def start_requests(self):
        yield feapder.Request(
            "https://example.com",
            callback=self.parse_category,
            auto_inherit_context=True,
            site_id=1,
            site_name="站点A"
        )

    def parse_category(self, request, response):
        site_id = request.site_id
        site_name = request.site_name

        # 【来源1】局部变量
        category_name = response.xpath('//h1/text()').get()

        for category in categories:
            yield feapder.Request(
                url=category_url,
                callback=self.parse_shop_list,
                auto_inherit_context=True,
                # 【来源3】新增参数
                category_id=category['id']
                # site_id, site_name, category_name 会自动传递
            )

    def parse_shop_list(self, request, response):
        # 自动获得：site_id, site_name, category_id, category_name
        category_id = request.category_id
        category_name = request.category_name

        # 【来源1】新的局部变量
        shop_name = response.xpath('//div[@class="shop"]/text()').get()

        for product in products:
            yield feapder.Request(
                url=product_url,
                callback=self.parse_product,
                auto_inherit_context=True,
                product_id=product['id']
                # 所有之前的参数都会自动传递
            )

    def parse_product(self, request, response):
        # 自动获得所有需要的参数
        site_id = request.site_id
        category_id = request.category_id
        shop_name = request.shop_name
        product_id = request.product_id

        # 保存数据
        yield Item(...)
```

---

## 常见问题

### Q1: 会影响性能吗？

A: **几乎不影响**
- 静态分析只在 Spider 启动时执行一次
- 运行时只是栈帧查询和属性复制，开销极小（< 0.1ms）

### Q2: 所有访问方式都能检测到吗？

A: **99% 的代码可以检测**

✅ **可以检测**:
```python
category_id = request.category_id  # 标准属性访问
```

❌ **无法检测**:
```python
# 动态访问
attr_name = 'category_id'
value = getattr(request, attr_name)

# 字典访问
value = request.__dict__['category_id']
```

**解决方案**: 这种情况极少，如果遇到，建议改用标准访问方式。

### Q3: response.xxx 解析的数据会被捕获吗？

A: **会捕获**

从 response 解析出来的数据（如 `item_id = response.xpath('//div/@id').get()`），只要你把它赋值给了局部变量，并且后面的回调需要用到，就会被自动捕获。

```python
def parse_list(self, request, response):
    # 这个会被捕获
    item_id = response.xpath('//div/@data-id').get()

    yield feapder.Request(
        url=url,
        callback=self.parse_detail,
        auto_inherit_context=True
        # item_id 会自动传递
    )

def parse_detail(self, request, response):
    item_id = request.item_id  # ✅ 可以访问
```

### Q4: 如何调试参数传递？

A: 查看日志输出

```
[智能上下文] 分析完成，检测到 3 个回调函数
[智能上下文]   parse_list: {'category_id', 'shop_name'}
[智能上下文]   parse_detail: {'category_id', 'item_id'}
```

### Q5: 可以和手动传递混用吗？

A: **可以**，显式传递的参数优先级更高

```python
yield feapder.Request(
    url=url,
    callback=self.parse,
    auto_inherit_context=True,
    category_id=999,  # ✅ 显式设置，会覆盖自动捕获的值
)
```

### Q6: 私有变量会被捕获吗？

A: **不会**

以 `_` 开头的变量不会被自动捕获：

```python
def parse_list(self, request, response):
    _private_var = "私有数据"  # ❌ 不会被捕获
    public_var = "公开数据"    # ✅ 会被捕获（如果后面需要）
```

### Q7: 过大的对象（如超大字符串）会被捕获吗？

A: **大于1MB的对象会被自动跳过**

为了避免内存占用过高，框架会自动检测对象大小：
- ✅ **< 1MB**: 正常传递
- ❌ **≥ 1MB**: 自动跳过，并记录警告日志

```python
def parse(self, request, response):
    small_data = "正常数据"  # ✅ 会被传递
    huge_list = [x for x in range(1000000)]  # ❌ 超过1MB，会被跳过

    yield Request(url, callback=self.parse_detail, auto_inherit_context=True)
    # 日志: [智能上下文] 跳过大对象 huge_list (大小: 8.01MB)
```

**解决方案**: 如果确实需要传递大对象，建议：
1. 使用显式传递（不受大小限制）
2. 或者将大对象保存到数据库/文件，只传递ID

### Q8: None 值会被传递吗？

A: **看情况**

- ✅ **局部变量的 None**: 会传递（允许用户显式清除父级的值）
- ❌ **父请求的 None**: 不传递（避免传递空值）

```python
def parse_level1(self, request, response):
    category_id = 100
    yield Request(url, callback=self.parse_level2, auto_inherit_context=True)

def parse_level2(self, request, response):
    # 想清除 category_id
    category_id = None  # ✅ 会传递给下一层
    yield Request(url, callback=self.parse_level3, auto_inherit_context=True)

def parse_level3(self, request, response):
    print(request.category_id)  # None（符合预期）
```

---

## 最佳实践

### 1. 推荐用法

```python
class MySpider(feapder.Spider):
    __custom_setting__ = dict(
        SMART_CONTEXT_ENABLE=True,
    )

    def parse_list(self, request, response):
        # 需要传递的数据赋值给局部变量
        item_id = response.xpath('//div/@id').get()
        item_name = response.xpath('//div/text()').get()

        yield feapder.Request(
            url=item_url,
            callback=self.parse_detail,
            auto_inherit_context=True,  # ✅ 简洁明了
            # item_id 和 item_name 会自动传递
        )
```

### 2. 使用标准属性访问

```python
# ✅ 推荐
category_id = request.category_id

# ❌ 不推荐（无法被静态分析）
category_id = getattr(request, 'category_id')
```

### 3. 明确参数意图

```python
def parse_list(self, request, response):
    # ✅ 好的命名，清晰表达意图
    category_id = request.category_id
    category_name = response.xpath('//h1/text()').get()

    # ❌ 不好的命名
    cid = request.category_id
    data = response.xpath('//h1/text()').get()
```

---

## 注意事项

1. ⚠️ 需要能获取到源代码（不支持交互式环境如 REPL）
2. ⚠️ 动态属性访问无法检测（如 `getattr(request, attr_name)`）
3. ⚠️ 私有属性（以 `_` 开头）不会被继承
4. ⚠️ 框架保留字段不会被继承（如 `url`, `callback`, `method` 等）
5. ⚠️ Response 对象本身不会被传递，但从 response 解析的数据会被传递

---

## 总结

智能上下文管理通过**静态分析 + 运行时捕获**，实现了：

- ✅ **自动化**: 无需手动管理参数列表
- ✅ **三种来源**: 自动捕获局部变量、request 属性、显式传入
- ✅ **内存优化**: 只传递必要参数
- ✅ **向下兼容**: 默认关闭，不影响现有代码
- ✅ **通用性强**: 支持所有 Spider 类型

**开始使用**: 只需在 `__custom_setting__` 中添加 `SMART_CONTEXT_ENABLE=True`，然后在 Request 中使用 `auto_inherit_context=True` 即可！
